#include <gtest/gtest.h>

#include <pagoda/common/debug/logger.h>
#include <pagoda/common/fs/file_util.h>
#include <pagoda/common/instrument/profiler.h>
#include <pagoda/common/version.h>
#include <pagoda/geometry/geometry_system.h>
#include <pagoda/graph/default_scheduler.h>
#include <pagoda/graph/graph.h>
#include <pagoda/graph/io/reader.h>
#include <pagoda/graph/io/writer.h>
#include <pagoda/graph/query/query.h>
#include <pagoda/objects/hierarchical_system.h>
#include <pagoda/objects/procedural_object.h>

#include <pagoda/pagoda.h>

#include <boost/filesystem/path.hpp>

using namespace pagoda;
using namespace pagoda::common;
using namespace pagoda::graph;
using namespace pagoda::graph::io;

class RegressionTest
{
	public:
	static void SetShouldWriteFiles(const bool& write)
	{
		s_writeFiles = write;
	}

	static boost::filesystem::path GetTestFilesDirectory()
	{
		return "@CMAKE_CURRENT_SOURCE_DIR@";
	}

	RegressionTest(const std::string& name) : m_regressionTestName(name)
	{
		ClearDirectory();
		ReadGraphFromFile(GetInputGraph().string());
		ExecuteGraph();
		MatchFiles();
		TestWriter();
	}

	boost::filesystem::path GetInputGraph()
	{
		auto pathToGraphFile = GetTestFilesDirectory();
		pathToGraphFile /= "test_files";
		pathToGraphFile /= get_os();
		pathToGraphFile /= get_compiler_id();
		pathToGraphFile /= m_regressionTestName;
		pathToGraphFile /= m_regressionTestName + ".pgd";
		return pathToGraphFile;
	}

	boost::filesystem::path GetExpectedResultsDir()
	{
		auto dir = GetTestFilesDirectory();
		dir /= "test_files";
		dir /= get_os();
		dir /= get_compiler_id();
		dir /= m_regressionTestName;
		if (!boost::filesystem::exists(dir)) {
			fs::CreateDirectories(dir);
		}
		return dir;
	}

	boost::filesystem::path GetExpectedResultFile(
	  const boost::filesystem::path& expectedFile)
	{
		return GetExpectedResultsDir() / expectedFile;
	}

	std::set<boost::filesystem::path> GetAllExpectedFiles()
	{
		std::set<boost::filesystem::path> files;
		fs::GetAllFilesWithExtension(GetExpectedResultsDir(), ".obj",
		                             std::inserter(files, files.end()));
		return files;
	}

	boost::filesystem::path GetResultsDir()
	{
		boost::filesystem::path p = "regression_results";
		p /= m_regressionTestName;
		return p;
	}

	boost::filesystem::path GetResultFile(const boost::filesystem::path& f)
	{
		return GetResultsDir() / f;
	}

	std::set<boost::filesystem::path> GetAllResultFiles()
	{
		std::set<boost::filesystem::path> files;
		fs::GetAllFilesWithExtension(GetResultsDir(), ".obj",
		                             std::inserter(files, files.end()));
		return files;
	}

	void ClearDirectory()
	{
		boost::filesystem::remove_all(GetResultsDir());
	}

	std::shared_ptr<Graph> ReadGraphFromFile(const std::string& filePath)
	{
		m_graph = m_pagoda.CreateGraphFromFile(filePath);
		return m_graph;
	}

	void ExecuteGraph()
	{
		m_graph->Execute();
	}

	void MatchFiles()
	{
		auto expectedFiles = GetAllExpectedFiles();
		auto resultFiles = GetAllResultFiles();

		if (s_writeFiles) {
			for (const auto& f : expectedFiles) {
				boost::filesystem::remove(GetExpectedResultFile(f));
			}
			for (const auto& f : resultFiles) {
				boost::filesystem::copy(GetResultFile(f), GetExpectedResultFile(f));
			}
		} else {
			EXPECT_EQ(expectedFiles, resultFiles);
			for (const auto& f : expectedFiles) {
				std::string resultFile = fs::LoadFileToString(GetResultFile(f));
				std::string expectedFile =
				  fs::LoadFileToString(GetExpectedResultFile(f));
				EXPECT_EQ(expectedFile, resultFile);
			}
		}
	}

	void TestWriter()
	{
		GraphWriter writer(m_graph);
		std::stringstream out;
		writer.Write(out);
		auto outStr1 = out.str();
		std::shared_ptr<Graph> graph2 = nullptr;
		try {
			graph2 = m_pagoda.CreateGraphFromString(outStr1);
		} catch (common::exception::Exception& e) {
			std::cerr << "Failed to read graph" << std::endl;
			std::cerr << e.What() << std::endl;
			FAIL();
		} catch (std::runtime_error& e) {
			std::cerr << "Runtime error" << std::endl;
			std::cerr << e.what() << std::endl;
			FAIL();
		}

		NodeSet nodes;
		query::Query q{*m_graph, nodes};
		m_graph->ExecuteQuery(q);

		NodeSet newGraphNodes;
		query::Query q2{*graph2, newGraphNodes};
		graph2->ExecuteQuery(q2);

		EXPECT_EQ(nodes.size(), newGraphNodes.size());

		auto compareNodeSets = [](const NodeSet& ns1, const NodeSet& ns2) {
			ASSERT_EQ(ns1.size(), ns2.size());
			for (auto n1 : ns1) {
				auto found = std::find_if(ns2.begin(), ns2.end(),
				                          [&n1](const std::shared_ptr<Node>& n) {
					                          return n->GetName() == n1->GetName();
				                          });
				ASSERT_NE(found, ns2.end());

				auto parEnd = n1->GetMembersEnd();
				for (auto parIter = n1->GetMembersBegin(); parIter != parEnd;
				     ++parIter) {
					auto par = (*found)->GetMember(parIter->first);
					ASSERT_NE(par, nullptr);
					EXPECT_EQ(parIter->second.m_value->ToString(), par->ToString());
				}
			}
		};

		for (auto n : nodes) {
			auto n2 = graph2->GetNode(n->GetName());
			ASSERT_NE(n2, nullptr);
			auto inNodes = m_graph->GetNodeInputNodes(n->GetName());
			auto inNodes2 = graph2->GetNodeInputNodes(n2->GetName());

			compareNodeSets(m_graph->GetNodeInputNodes(n->GetName()),
			                graph2->GetNodeInputNodes(n2->GetName()));
			compareNodeSets(m_graph->GetNodeOutputNodes(n->GetName()),
			                graph2->GetNodeOutputNodes(n2->GetName()));
		}
	}

	private:
	std::string m_regressionTestName;

	GraphPtr m_graph;
	Pagoda m_pagoda;

	static bool s_writeFiles;
};
bool RegressionTest::s_writeFiles = false;

#define REGRESSION_TEST(NAME)    \
	TEST(RegressionTestCase, NAME) \
	{                              \
		RegressionTest(#NAME);       \
	}

REGRESSION_TEST(create_rect)
REGRESSION_TEST(create_box)
REGRESSION_TEST(create_sphere)
REGRESSION_TEST(export_geometry)
REGRESSION_TEST(expression)
REGRESSION_TEST(extrusion)
// REGRESSION_TEST(parameter_definition)
// REGRESSION_TEST(parameter_overwrite)
// REGRESSION_TEST(parameter_renaming)
REGRESSION_TEST(clip_geometry)
REGRESSION_TEST(triangulate_geometry)
REGRESSION_TEST(translate)
REGRESSION_TEST(repeat_split)
REGRESSION_TEST(face_offset)
REGRESSION_TEST(extract_faces)
REGRESSION_TEST(router)
REGRESSION_TEST(split)
REGRESSION_TEST(scale)
REGRESSION_TEST(rotate)
// REGRESSION_TEST(parameters_in_procedural_objects)
REGRESSION_TEST(scope_texture_projection)
REGRESSION_TEST(banner)

int main(int argc, char* argv[])
{
	bool writeFiles = false;
	for (auto i = 1; i < argc; ++i) {
		if (std::string(argv[i]) == "--writeFiles") {
			writeFiles = true;
			break;
		}
	}
	RegressionTest::SetShouldWriteFiles(writeFiles);
	::testing::InitGoogleTest(&argc, argv);

	auto returnVal = RUN_ALL_TESTS();

	instrument::ConsoleProfilerLogger consoleLogger(
	  instrument::ProfilerManager::Instance());
	consoleLogger.Log(20);

	return returnVal;
}
